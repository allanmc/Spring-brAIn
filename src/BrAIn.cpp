/*
	Copyright (c) 2008 Robin Vobruba <hoijui.quaero@gmail.com>

	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "BrAIn.h"


#include "ExternalAI/Interface/AISEvents.h"
#include "ExternalAI/Interface/AISCommands.h"

// generated by the C++ Wrapper scripts
#include "Unit.h"
#include "UnitDef.h"
#include "Engine.h"

brainSpace::BrAIn::BrAIn(springai::AICallback* callback):
		callback(callback),
		teamId(callback != NULL ? callback->GetTeamId() : -1)
		{
			decision = new Decision(callback);
		}

brainSpace::BrAIn::~BrAIn() {}

int brainSpace::BrAIn::HandleEvent(int topic, const void* data) {

	switch (topic) {
		case EVENT_UNIT_CREATED: {
			struct SUnitCreatedEvent* evt = (struct SUnitCreatedEvent*) data;
			int unitId = evt->unit;
			
			// TODO: wrapp events and commands too
			
			std::string unitDefName = callback->GetFriendlyUnits()[0]->GetDef()->GetName();
			
			std::string msgText = "Hello Engine (from CppTestA), first friendly untis def name is: " + unitDefName;
			SSendTextMessageCommand cmd;
			cmd.text = msgText.c_str();
			cmd.zone = 0;
			int ret = callback->GetEngine()->HandleCommand(0, -1, COMMAND_SEND_TEXT_MESSAGE, &cmd);
			

			break;
		}
		case EVENT_UNIT_FINISHED:
		{
			struct SUnitFinishedEvent* evt = (struct SUnitFinishedEvent*) data;
			int unitId = evt->unit;
			decision->UnitFinished(unitId);
			break;
		}
		case EVENT_UNIT_DESTROYED:
		{
			struct SUnitDestroyedEvent* evt = (struct SUnitDestroyedEvent*) data;
			int unitId = evt->unit;
			int attackerId = evt->attacker;
			decision->UnitDestroyed(unitId, attackerId);
			break;
		}
		case EVENT_UPDATE:
		{
			struct SUpdateEvent* evt = (struct SUpdateEvent*) data;
			int frame = evt->frame;
			decision->Update(frame);
			break;
		}
		default: {
			ChatMsg("recived an unhandled event with topic: %d",topic); 
			break;
		}
	}

	// signal: everything went OK
	return 0;
}

void brainSpace::BrAIn::ChatMsg(const char* msg, ...)
{
	static char c[200];
	va_list list;
	va_start(list, msg);
	SNPRINTF(c, 200, msg, list);
	va_end(list);
	SSendTextMessageCommand cmd;
	cmd.text = c;
	cmd.zone = 0;
	callback->GetEngine()->HandleCommand(0, -1, COMMAND_SEND_TEXT_MESSAGE, &cmd);
}

void brainSpace::BrAIn::ChatMsg(std::string msg)
{
	SSendTextMessageCommand cmd;
	cmd.text = msg.c_str();
	cmd.zone = 0;
	callback->GetEngine()->HandleCommand(0, -1, COMMAND_SEND_TEXT_MESSAGE, &cmd);
}
